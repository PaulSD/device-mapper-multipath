From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Benjamin Marzinski <bmarzins@redhat.com>
Date: Fri, 16 Jul 2021 12:39:17 -0500
Subject: [PATCH] multipath: print warning if multipathd is not running.

If multipath notices that multipath devices exist or were created, and
multipathd is not running, it now prints a warning message, so users are
notified of the issue.

Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 libmultipath/configure.c          | 13 +++++++++++--
 libmultipath/configure.h          |  1 +
 libmultipath/libmultipath.version |  5 +++++
 multipath/main.c                  |  5 +++++
 4 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/libmultipath/configure.c b/libmultipath/configure.c
index a6ae3359..eb76fbc4 100644
--- a/libmultipath/configure.c
+++ b/libmultipath/configure.c
@@ -1083,7 +1083,8 @@ deadmap (struct multipath * mpp)
 	return 1; /* dead */
 }
 
-int check_daemon(void)
+extern int
+check_daemon(void)
 {
 	int fd;
 	char *reply;
@@ -1138,6 +1139,8 @@ int coalesce_paths (struct vectors *vecs, vector mpvec, char *refwwid,
 	struct config *conf;
 	int allow_queueing;
 	struct bitfield *size_mismatch_seen;
+	bool map_processed = false;
+	bool no_daemon = false;
 
 	/* ignore refwwid if it's empty */
 	if (refwwid && !strlen(refwwid))
@@ -1288,7 +1291,9 @@ int coalesce_paths (struct vectors *vecs, vector mpvec, char *refwwid,
 		conf = get_multipath_config();
 		allow_queueing = conf->allow_queueing;
 		put_multipath_config(conf);
-		if (!is_daemon && !allow_queueing && !check_daemon()) {
+		if (!is_daemon && !allow_queueing &&
+		    (no_daemon || !check_daemon())) {
+			no_daemon = true;
 			if (mpp->no_path_retry != NO_PATH_RETRY_UNDEF &&
 			    mpp->no_path_retry != NO_PATH_RETRY_FAIL)
 				condlog(3, "%s: multipathd not running, unset "
@@ -1311,6 +1316,7 @@ int coalesce_paths (struct vectors *vecs, vector mpvec, char *refwwid,
 		else
 			remove_map(mpp, vecs->pathvec, vecs->mpvec,
 				   KEEP_VEC);
+		map_processed = true;
 	}
 	/*
 	 * Flush maps with only dead paths (ie not in sysfs)
@@ -1336,6 +1342,9 @@ int coalesce_paths (struct vectors *vecs, vector mpvec, char *refwwid,
 				condlog(2, "%s: remove (dead)", alias);
 		}
 	}
+	if (map_processed && !is_daemon && (no_daemon || !check_daemon()))
+		condlog(2, "multipath devices exist, but multipathd service is not running");
+
 	ret = CP_OK;
 out:
 	free(size_mismatch_seen);
diff --git a/libmultipath/configure.h b/libmultipath/configure.h
index 70cf77a3..741066b3 100644
--- a/libmultipath/configure.h
+++ b/libmultipath/configure.h
@@ -60,3 +60,4 @@ struct udev_device *get_udev_device(const char *dev, enum devtypes dev_type);
 void trigger_paths_udev_change(struct multipath *mpp, bool is_mpath);
 void trigger_partitions_udev_change(struct udev_device *dev, const char *action,
 				    int len);
+int check_daemon(void);
diff --git a/libmultipath/libmultipath.version b/libmultipath/libmultipath.version
index 0cff3111..d8be5fd2 100644
--- a/libmultipath/libmultipath.version
+++ b/libmultipath/libmultipath.version
@@ -274,3 +274,8 @@ global:
 local:
 	*;
 };
+
+LIBMULTIPATH_5.1.0 {
+global:
+	check_daemon;
+} LIBMULTIPATH_5.0.0;
diff --git a/multipath/main.c b/multipath/main.c
index 8fc0e15f..33377147 100644
--- a/multipath/main.c
+++ b/multipath/main.c
@@ -180,6 +180,7 @@ get_dm_mpvec (enum mpath_cmds cmd, vector curmp, vector pathvec, char * refwwid)
 	int i;
 	struct multipath * mpp;
 	int flags = (cmd == CMD_LIST_SHORT ? DI_NOIO : DI_ALL);
+	bool maps_present = false;
 
 	if (dm_get_maps(curmp))
 		return 1;
@@ -212,11 +213,15 @@ get_dm_mpvec (enum mpath_cmds cmd, vector curmp, vector pathvec, char * refwwid)
 
 		if (cmd == CMD_CREATE)
 			reinstate_paths(mpp);
+
+		maps_present = true;
 	}
 
 	if (cmd == CMD_LIST_SHORT || cmd == CMD_LIST_LONG)
 		print_foreign_topology(libmp_verbosity);
 
+	if (maps_present && !check_daemon())
+		condlog(2, "multipath devices exist, but multipathd service is not running");
 	return 0;
 }
 
