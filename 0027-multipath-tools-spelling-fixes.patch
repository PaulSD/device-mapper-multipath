From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Josh Soref <2119212+jsoref@users.noreply.github.com>
Date: Sun, 31 Jul 2022 13:17:53 -0400
Subject: [PATCH] multipath-tools: spelling fixes

Spelling errors detected by the GitHub check-spelling action:
https://github.com/marketplace/actions/check-spelling

Signed-off-by: Josh Soref <2119212+jsoref@users.noreply.github.com>
Reviewed-by: Martin Wilck <mwilck@suse.com>
Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 .github/workflows/foreign.yaml           |  2 +-
 kpartx/crc32.c                           |  2 +-
 kpartx/gpt.c                             |  2 +-
 libdmmp/libdmmp_path.c                   |  2 +-
 libmpathcmd/mpath_cmd.h                  |  2 +-
 libmpathpersist/mpath_persist_int.c      |  2 +-
 libmpathvalid/mpath_valid.h              |  4 ++--
 libmultipath/checkers/directio.c         |  2 +-
 libmultipath/config.h                    |  2 +-
 libmultipath/configure.c                 |  2 +-
 libmultipath/discovery.c                 |  2 +-
 libmultipath/nvme/nvme.h                 |  2 +-
 libmultipath/prioritizers/datacore.c     |  4 ++--
 libmultipath/prioritizers/hds.c          |  2 +-
 libmultipath/prioritizers/path_latency.c |  4 ++--
 libmultipath/strbuf.h                    |  4 ++--
 libmultipath/structs_vec.c               |  2 +-
 libmultipath/uevent.c                    |  2 +-
 libmultipath/valid.h                     |  2 +-
 mpathpersist/main.c                      |  2 +-
 multipath/multipath.conf.5               | 14 +++++++-------
 multipathd/main.c                        | 10 +++++-----
 tests/directio.c                         |  2 +-
 tests/hwtable.c                          | 10 +++++-----
 tests/mpathvalid.c                       |  2 +-
 tests/pgpolicy.c                         |  2 +-
 tests/valid.c                            |  4 ++--
 third-party/valgrind/valgrind.h          |  8 ++++----
 28 files changed, 50 insertions(+), 50 deletions(-)

diff --git a/.github/workflows/foreign.yaml b/.github/workflows/foreign.yaml
index e9ffd3d8..32915186 100644
--- a/.github/workflows/foreign.yaml
+++ b/.github/workflows/foreign.yaml
@@ -56,7 +56,7 @@ jobs:
       - name: enable foreign arch
         run: sudo docker run --rm --privileged multiarch/qemu-user-static:register --reset
       - name: run tests
-        # Github actions doesn't support referencing docker images with
+        # GitHub actions doesn't support referencing docker images with
         # context variables. Workaround: use mosteo-actions/docker-run action
         # See https://github.community/t/expressions-in-docker-uri/16271
         uses: mosteo-actions/docker-run@v1
diff --git a/kpartx/crc32.c b/kpartx/crc32.c
index e688f8e9..df6c6878 100644
--- a/kpartx/crc32.c
+++ b/kpartx/crc32.c
@@ -290,7 +290,7 @@ uint32_t attribute((pure)) crc32_be(uint32_t crc, unsigned char const *p, size_t
  * the end, so we have to add 32 extra cycles shifting in zeros at the
  * end of every message,
  *
- * So the standard trick is to rearrage merging in the next_input_bit()
+ * So the standard trick is to rearrange merging in the next_input_bit()
  * until the moment it's needed.  Then the first 32 cycles can be precomputed,
  * and merging in the final 32 zero bits to make room for the CRC can be
  * skipped entirely.
diff --git a/kpartx/gpt.c b/kpartx/gpt.c
index 34a910cf..47d8743e 100644
--- a/kpartx/gpt.c
+++ b/kpartx/gpt.c
@@ -357,7 +357,7 @@ is_gpt_valid(int fd, uint64_t lba,
 			__le32_to_cpu((*gpt)->num_partition_entries) *
 			__le32_to_cpu((*gpt)->sizeof_partition_entry));
 	if (crc != __le32_to_cpu((*gpt)->partition_entry_array_crc32)) {
-		// printf("GUID Partitition Entry Array CRC check failed.\n");
+		// printf("GUID Partition Entry Array CRC check failed.\n");
 		free(*gpt);
 		*gpt = NULL;
 		free(*ptes);
diff --git a/libdmmp/libdmmp_path.c b/libdmmp/libdmmp_path.c
index 47a2162c..21714b15 100644
--- a/libdmmp/libdmmp_path.c
+++ b/libdmmp/libdmmp_path.c
@@ -28,7 +28,7 @@
 #include "libdmmp_private.h"
 
 #define _DMMP_SHOW_PS_INDEX_BLK_NAME	0
-#define _DMMP_SHOW_PS_INDEX_SATAUS	1
+#define _DMMP_SHOW_PS_INDEX_STATUS	1
 #define _DMMP_SHOW_PS_INDEX_WWID	2
 #define _DMMP_SHOW_PS_INDEX_PGID	3
 
diff --git a/libmpathcmd/mpath_cmd.h b/libmpathcmd/mpath_cmd.h
index 30838b02..0c293c71 100644
--- a/libmpathcmd/mpath_cmd.h
+++ b/libmpathcmd/mpath_cmd.h
@@ -65,7 +65,7 @@ int mpath_connect(void);
 /*
  * DESCRIPTION:
  *	Disconnect from the multipathd daemon. This function must be
- *	run after after processing all the multipath commands.
+ *	run after processing all the multipath commands.
  *
  * RETURNS:
  *	0 on success. -1 on failure (with errno set).
diff --git a/libmpathpersist/mpath_persist_int.c b/libmpathpersist/mpath_persist_int.c
index e34fc32d..6924b379 100644
--- a/libmpathpersist/mpath_persist_int.c
+++ b/libmpathpersist/mpath_persist_int.c
@@ -601,7 +601,7 @@ static int mpath_prout_rel(struct multipath *mpp,int rq_servact, int rq_scope,
 		if (get_be64(mpp->reservation_key) &&
 			memcmp(pr_buff->prin_descriptor.prin_readfd.descriptors[i]->key,
 			       &mpp->reservation_key, 8)){
-			/*register with tarnsport id*/
+			/*register with transport id*/
 			memset(pamp, 0, length);
 			pamp->trnptid_list[0] = pptr;
 			memset (pamp->trnptid_list[0], 0, sizeof (struct transportid));
diff --git a/libmpathvalid/mpath_valid.h b/libmpathvalid/mpath_valid.h
index ec2f9392..3e34b1fd 100644
--- a/libmpathvalid/mpath_valid.h
+++ b/libmpathvalid/mpath_valid.h
@@ -112,7 +112,7 @@ int mpathvalid_exit(void);
  * RETURNS:
  * 	MPATH_STRICT, MPATH_SMART, MPATH_GREEDY, or MPATH_MODE_ERROR
  *
- * 	MPATH_STRICT     = find_multiapths (yes|on|no|off)
+ * 	MPATH_STRICT     = find_multipaths (yes|on|no|off)
  * 	MPATH_SMART      = find_multipaths smart
  * 	MPATH_GREEDY     = find_multipaths greedy
  * 	MPATH_MODE_ERROR = multipath configuration not initialized
@@ -126,7 +126,7 @@ unsigned int mpathvalid_get_mode(void);
  * 	potentially claimed (MPATH_IS_VALID, MPATH_IS_VALID_NO_CHECK,
  * 	or MPATH_IS_MAYBE_VALID) and wwid is not NULL, then *wiid will
  * 	be set to point to the wwid of device. If set, *wwid must be
- * 	freed by the caller. path_wwids is an obptional parameter that
+ * 	freed by the caller. path_wwids is an optional parameter that
  * 	points to an array of wwids, that were returned from previous
  * 	calls to mpathvalid_is_path(). These are wwids of existing
  * 	devices that are or potentially are claimed by device-mapper
diff --git a/libmultipath/checkers/directio.c b/libmultipath/checkers/directio.c
index bc7b7be5..a326e37b 100644
--- a/libmultipath/checkers/directio.c
+++ b/libmultipath/checkers/directio.c
@@ -124,7 +124,7 @@ remove_aio_group(struct aio_group *aio_grp)
 
 /* If an aio_group is completely full of orphans, then no checkers can
  * use it, which means that no checkers can clear out the orphans. To
- * avoid keeping the useless group around, simply remove remove the
+ * avoid keeping the useless group around, simply remove the
  * group */
 static void
 check_orphaned_group(struct aio_group *aio_grp)
diff --git a/libmultipath/config.h b/libmultipath/config.h
index 36d40157..fdcdff0a 100644
--- a/libmultipath/config.h
+++ b/libmultipath/config.h
@@ -248,7 +248,7 @@ struct config {
  * libmultipath calls. If an application wants to keep using the
  * udev variable after calling libmultipath_exit(), it should have taken
  * an additional reference on it beforehand. This is the case e.g.
- * after initiazing udev with udev_new().
+ * after initializing udev with udev_new().
  */
 extern struct udev *udev;
 
diff --git a/libmultipath/configure.c b/libmultipath/configure.c
index 4427f910..8af7cd79 100644
--- a/libmultipath/configure.c
+++ b/libmultipath/configure.c
@@ -397,7 +397,7 @@ int setup_map(struct multipath *mpp, char **params, struct vectors *vecs)
 	 * into a mp->params strings to feed the device-mapper
 	 */
 	if (assemble_map(mpp, params)) {
-		condlog(0, "%s: problem assembing map", mpp->alias);
+		condlog(0, "%s: problem assembling map", mpp->alias);
 		return 1;
 	}
 	return 0;
diff --git a/libmultipath/discovery.c b/libmultipath/discovery.c
index ee290093..15560f8c 100644
--- a/libmultipath/discovery.c
+++ b/libmultipath/discovery.c
@@ -1344,7 +1344,7 @@ parse_vpd_c0_hp3par(const unsigned char *in, size_t in_len,
 		condlog(3, "HP/3PAR vendor specific VPD page length too short: %zu", in_len);
 		return -EINVAL;
 	}
-	if (in[4] <= 3) /* revision must be > 3 to have Vomlume Name */
+	if (in[4] <= 3) /* revision must be > 3 to have Volume Name */
 		return -ENODATA;
 	len = get_unaligned_be32(&in[40]);
 	if (len > out_len || len + 44 > in_len) {
diff --git a/libmultipath/nvme/nvme.h b/libmultipath/nvme/nvme.h
index 7e0278b5..57f82a31 100644
--- a/libmultipath/nvme/nvme.h
+++ b/libmultipath/nvme/nvme.h
@@ -224,7 +224,7 @@ char *nvme_char_from_block(char *block);
  * Notes:  This function does not care about transport so that the offset is
  * not going to be checked inside of this function for the unsupported fields
  * in a specific transport.  For example, BPMBL(Boot Partition Memory Buffer
- * Location) register is not supported by fabrics, but it can be chcked here.
+ * Location) register is not supported by fabrics, but it can be checked here.
  */
 static inline bool is_64bit_reg(__u32 offset)
 {
diff --git a/libmultipath/prioritizers/datacore.c b/libmultipath/prioritizers/datacore.c
index 02dc2e27..d1d473d4 100644
--- a/libmultipath/prioritizers/datacore.c
+++ b/libmultipath/prioritizers/datacore.c
@@ -1,6 +1,6 @@
 /*
  * (C) 2010 Christophe Varoqui
- * (C) 2009 Dembach Goo Infromatik GmbH & Co KG
+ * (C) 2009 Dembach Goo Informatik GmbH & Co KG
  * Manon Goo <manon.goo@dg-i.net>
  *
  * datacore.c
@@ -10,7 +10,7 @@
  * Matthias Rudolph <matthias.rudolph@hds.com>
  *
  * This work is made available on the basis of the
- * GPLv2 for detials see <http://www.gnu.org/licenses/>.
+ * GPLv2 for details see <http://www.gnu.org/licenses/>.
  *
  * Manon Goo 2009
  *
diff --git a/libmultipath/prioritizers/hds.c b/libmultipath/prioritizers/hds.c
index 88cac5f0..d569f2d7 100644
--- a/libmultipath/prioritizers/hds.c
+++ b/libmultipath/prioritizers/hds.c
@@ -32,7 +32,7 @@
  * Half of the LUNs are accessed via one HBA/storage controller and the other
  * half via the other HBA/storage controller.
  *
- * In cluster environmemnts (RAC) it also guarantees that all cluster nodes have
+ * In cluster environments (RAC) it also guarantees that all cluster nodes have
  * access to the LDEVs via the same controller.
  *
  * You can run the prioritizer manually in verbose mode:
diff --git a/libmultipath/prioritizers/path_latency.c b/libmultipath/prioritizers/path_latency.c
index e155f6dc..2f5be9b9 100644
--- a/libmultipath/prioritizers/path_latency.c
+++ b/libmultipath/prioritizers/path_latency.c
@@ -64,7 +64,7 @@ static int prepare_directio_read(int fd, int *blksz, char **pbuf,
 	long flags;
 
 	if (ioctl(fd, BLKBSZGET, blksz) < 0) {
-		pp_pl_log(3,"catnnot get blocksize, set default");
+		pp_pl_log(3,"cannot get blocksize, set default");
 		*blksz = DEF_BLK_SIZE;
 	}
 	if (posix_memalign((void **)pbuf, pgsize, *blksz))
@@ -193,7 +193,7 @@ out:
 }
 
 /*
- * Do not scale the prioriy in a certain range such as [0, 1024]
+ * Do not scale the priority in a certain range such as [0, 1024]
  * because scaling will eliminate the effect of base_num.
  */
 int calcPrio(double lg_avglatency, double lg_maxavglatency,
diff --git a/libmultipath/strbuf.h b/libmultipath/strbuf.h
index 41d7d54f..31ab519a 100644
--- a/libmultipath/strbuf.h
+++ b/libmultipath/strbuf.h
@@ -159,7 +159,7 @@ int fill_strbuf(struct strbuf *buf, char c, int slen);
  *
  * Appends the given string to @strbuf, with leading and trailing double
  * quotes (") added, expanding @strbuf's size as necessary. Any double quote
- * characters (") in the string are transformed to double double quotes ("").
+ * characters (") in the string are transformed to a pair of double quotes ("").
  * If the function returns an error, @strbuf is unchanged.
  */
 int append_strbuf_quoted(struct strbuf *buf, const char *str);
@@ -171,7 +171,7 @@ int append_strbuf_quoted(struct strbuf *buf, const char *str);
  * @returns: number of appended characters if successful, (excluding
  * terminating '\0'); negative error code otherwise
  *
- * Appends the the arguments following @fmt, formatted as in printf(), to
+ * Appends the arguments following @fmt, formatted as in printf(), to
  * @strbuf, expanding @strbuf's size as necessary. The function makes sure that
  * the output @strbuf is always 0-terminated.
  * If the function returns an error, @strbuf is unchanged.
diff --git a/libmultipath/structs_vec.c b/libmultipath/structs_vec.c
index a69f0643..645896c6 100644
--- a/libmultipath/structs_vec.c
+++ b/libmultipath/structs_vec.c
@@ -205,7 +205,7 @@ static bool update_pathvec_from_dm(vector pathvec, struct multipath *mpp,
 				continue;
 
 			/*
-			 * At this point, pp->udev is valid and and pp->wwid
+			 * At this point, pp->udev is valid and pp->wwid
 			 * is the best we could get
 			 */
 			if (*pp->wwid && strcmp(mpp->wwid, pp->wwid)) {
diff --git a/libmultipath/uevent.c b/libmultipath/uevent.c
index 5793af94..57447ca0 100644
--- a/libmultipath/uevent.c
+++ b/libmultipath/uevent.c
@@ -373,7 +373,7 @@ uevent_filter(struct uevent *later, struct uevent_filter_state *st)
 
 	list_for_some_entry_reverse_safe(earlier, tmp, &later->node, &st->uevq, node) {
 		/*
-		 * filter unnessary earlier uevents
+		 * filter unnecessary earlier uevents
 		 * by the later uevent
 		 */
 		if (!list_empty(&earlier->merge_node)) {
diff --git a/libmultipath/valid.h b/libmultipath/valid.h
index ce1c7cbf..731e6eff 100644
--- a/libmultipath/valid.h
+++ b/libmultipath/valid.h
@@ -23,7 +23,7 @@
  * already.
  * PATH_IS_VALID is returned by is_path_valid, when the path is
  * valid only if it hasn't been released to systemd already.
- * PATH_IS_MAYBE_VALID is returned when the the path would be valid
+ * PATH_IS_MAYBE_VALID is returned when the path would be valid
  * if other paths with the same wwid existed. It is up to the caller
  * to check for these other paths.
  */
diff --git a/mpathpersist/main.c b/mpathpersist/main.c
index 4bdd55c2..894e8c94 100644
--- a/mpathpersist/main.c
+++ b/mpathpersist/main.c
@@ -480,7 +480,7 @@ static int handle_args(int argc, char * argv[], int nline)
 	}
 	if ((verbose > 2) && num_transportids)
 	{
-		fprintf (stderr, "number of tranport-ids decoded from "
+		fprintf (stderr, "number of transport-ids decoded from "
 				"command line : %d\n", num_transportids);
 	}
 
diff --git a/multipath/multipath.conf.5 b/multipath/multipath.conf.5
index c2d34f18..853e0feb 100644
--- a/multipath/multipath.conf.5
+++ b/multipath/multipath.conf.5
@@ -455,7 +455,7 @@ precedence. See KNOWN ISSUES.
 (Since kernel 2.6.38) Number of msecs before pg_init retry, it must be between 0 and 60000.
 .TP
 .I queue_mode <mode>
-(Since kernel 4.8) Select the the queueing mode per multipath device.
+(Since kernel 4.8) Select the queueing mode per multipath device.
 <mode> can be \fIbio\fR, \fIrq\fR or \fImq\fR, which corresponds to
 bio-based, request-based, and block-multiqueue (blk-mq) request-based,
 respectively.
@@ -935,7 +935,7 @@ This option is not supported any more. The value is ignored.
 .B san_path_err_threshold
 If set to a value greater than 0, multipathd will watch paths and check how many
 times a path has been failed due to errors.If the number of failures on a particular
-path is greater then the san_path_err_threshold, then the path will not reinstate
+path is greater than the san_path_err_threshold, then the path will not reinstate
 till san_path_err_recovery_time. These path failures should occur within a
 san_path_err_forget_rate checks, if not we will consider the path is good enough
 to reinstantate. See "Shaky paths detection" below.
@@ -949,7 +949,7 @@ The default is: \fBno\fR
 .B san_path_err_forget_rate
 If set to a value greater than 0, multipathd will check whether the path failures
 has exceeded  the san_path_err_threshold within this many checks i.e
-san_path_err_forget_rate . If so we will not reinstante the path till
+san_path_err_forget_rate . If so we will not reinstate the path till
 san_path_err_recovery_time. See "Shaky paths detection" below.
 .RS
 .TP
@@ -962,7 +962,7 @@ The default is: \fBno\fR
 If set to a value greater than 0, multipathd will make sure that when path failures
 has exceeded the san_path_err_threshold within san_path_err_forget_rate then the path
 will be placed in failed state for san_path_err_recovery_time duration.Once san_path_err_recovery_time
-has timeout  we will reinstante the failed path .
+has timeout  we will reinstate the failed path .
 san_path_err_recovery_time value should be in secs.
 See "Shaky paths detection" below.
 .RS
@@ -1000,7 +1000,7 @@ If the rate of IO error on a particular path is greater than the
 \fImarginal_path_err_rate_threshold\fR, then the path will not reinstate for
 \fImarginal_path_err_recheck_gap_time\fR seconds unless there is only one
 active path. After \fImarginal_path_err_recheck_gap_time\fR expires, the path
-will be requeueed for rechecking. If checking result is good enough, the
+will be requeued for rechecking. If checking result is good enough, the
 path will be reinstated. See "Shaky paths detection" below.
 .RS
 .TP
@@ -1031,7 +1031,7 @@ value, the failed path of  which the IO error rate is larger than
 \fImarginal_path_err_rate_threshold\fR will be kept in failed state for
 \fImarginal_path_err_recheck_gap_time\fR seconds. When
 \fImarginal_path_err_recheck_gap_time\fR seconds expires, the path will be
-requeueed for checking. If checking result is good enough, the path will be
+requeued for checking. If checking result is good enough, the path will be
 reinstated, or else it will keep failed. See "Shaky paths detection" below.
 .RS
 .TP
@@ -1379,7 +1379,7 @@ The protocol that a path is using can be viewed by running
 \fBmultipathd show paths format "%d %P"\fR
 .RE
 .LP
-For every device, these 5 blacklist criteria are evaluated in the the order
+For every device, these 5 blacklist criteria are evaluated in the order
 "property, dev\%node, device, protocol, wwid". If a device turns out to be
 blacklisted by any criterion, it's excluded from handling by multipathd, and
 the later criteria aren't evaluated any more. For each
diff --git a/multipathd/main.c b/multipathd/main.c
index a160c824..defee10a 100644
--- a/multipathd/main.c
+++ b/multipathd/main.c
@@ -583,7 +583,7 @@ retry:
 	if (mpp->prflag) {
 		vector_foreach_slot(mpp->paths, pp, i) {
 			if ((pp->state == PATH_UP)  || (pp->state == PATH_GHOST)) {
-				/* persistent reseravtion check*/
+				/* persistent reservation check*/
 				mpath_pr_event_handle(pp);
 			}
 		}
@@ -1515,7 +1515,7 @@ uev_update_path (struct uevent *uev, struct vectors * vecs)
 		condlog(3, "%s: error in change_foreign", __func__);
 		break;
 	default:
-		condlog(1, "%s: return code %d of change_forein is unsupported",
+		condlog(1, "%s: return code %d of change_foreign is unsupported",
 			__func__, rc);
 		break;
 	}
@@ -1966,7 +1966,7 @@ ghost_delay_tick(struct vectors *vecs)
 }
 
 static void
-defered_failback_tick (vector mpvec)
+deferred_failback_tick (vector mpvec)
 {
 	struct multipath * mpp;
 	unsigned int i;
@@ -2186,7 +2186,7 @@ static int check_path_reinstate_state(struct path * pp) {
 	get_monotonic_time(&curr_time);
 	/* when path failures has exceeded the san_path_err_threshold
 	 * place the path in delayed state till san_path_err_recovery_time
-	 * so that the cutomer can rectify the issue within this time. After
+	 * so that the customer can rectify the issue within this time. After
 	 * the completion of san_path_err_recovery_time it should
 	 * automatically reinstate the path
 	 * (note: we know that san_path_err_threshold > 0 here).
@@ -2647,7 +2647,7 @@ checkerloop (void *ap)
 		pthread_cleanup_push(cleanup_lock, &vecs->lock);
 		lock(&vecs->lock);
 		pthread_testcancel();
-		defered_failback_tick(vecs->mpvec);
+		deferred_failback_tick(vecs->mpvec);
 		retry_count_tick(vecs->mpvec);
 		missing_uev_wait_tick(vecs);
 		ghost_delay_tick(vecs);
diff --git a/tests/directio.c b/tests/directio.c
index 20ccc47a..01fdef28 100644
--- a/tests/directio.c
+++ b/tests/directio.c
@@ -497,7 +497,7 @@ static void test_free_with_pending(void **state)
         do_libcheck_reset(1);
 }
 
-/* test removing orpahed aio_group on free */
+/* test removing orphaned aio_group on free */
 static void test_orphaned_aio_group(void **state)
 {
 	struct checker c[AIO_GROUP_SIZE] = {{.cls = NULL}};
diff --git a/tests/hwtable.c b/tests/hwtable.c
index bfaf613f..334b75e8 100644
--- a/tests/hwtable.c
+++ b/tests/hwtable.c
@@ -29,7 +29,7 @@
 
 #define N_CONF_FILES 2
 
-static const char tmplate[] = "/tmp/hwtable-XXXXXX";
+static const char template[] = "/tmp/hwtable-XXXXXX";
 
 struct key_value {
 	const char *key;
@@ -136,7 +136,7 @@ static int setup(void **state)
 	if (hwt == NULL)
 		return -1;
 
-	snprintf(buf, sizeof(buf), "%s", tmplate);
+	snprintf(buf, sizeof(buf), "%s", template);
 	if (mkdtemp(buf) == NULL) {
 		condlog(0, "mkdtemp: %s", strerror(errno));
 		goto err;
@@ -255,7 +255,7 @@ static void write_defaults(const struct hwt_state *hwt)
 		{ "detect_prio", "no" },
 		{ "detect_checker", "no" },
 	};
-	char buf[sizeof(tmplate) + sizeof(bindings_name)];
+	char buf[sizeof(template) + sizeof(bindings_name)];
 	char dirbuf[PATH_MAX];
 
 	snprintf(buf, sizeof(buf), "%s/%s", hwt->tmpname, bindings_name);
@@ -308,7 +308,7 @@ static void write_device(FILE *ff, int nkv, const struct key_value *kv)
 }
 
 /*
- * Some macros to avoid boilerplace code
+ * Some macros to avoid boilerplate code
  */
 
 #define CHECK_STATE(state) ({ \
@@ -448,7 +448,7 @@ static const struct key_value npr_queue = { _no_path_retry, "queue" };
 /***** BEGIN TESTS SECTION *****/
 
 /*
- * Dump the configuration, subistitute the dumped configuration
+ * Dump the configuration, substitute the dumped configuration
  * for the current one, and verify that the result is identical.
  */
 static void replicate_config(const struct hwt_state *hwt, bool local)
diff --git a/tests/mpathvalid.c b/tests/mpathvalid.c
index 0230a88f..df66ed6a 100644
--- a/tests/mpathvalid.c
+++ b/tests/mpathvalid.c
@@ -399,7 +399,7 @@ static void test_mpathvalid_is_path_good3(void **state)
 	free(wwid);
 }
 
-/* mabybe valid with no matching paths */
+/* maybe valid with no matching paths */
 static void test_mpathvalid_is_path_good4(void **state)
 {
 	const char *wwids[] = { "WWID_A", "WWID_B", "WWID_C", "WWID_D" };
diff --git a/tests/pgpolicy.c b/tests/pgpolicy.c
index f116d12c..43be831f 100644
--- a/tests/pgpolicy.c
+++ b/tests/pgpolicy.c
@@ -191,7 +191,7 @@ verify_pathgroups(struct multipath *mp, struct path *pp, int **groups,
 			/* Test names instead of pointers to get a more
 			 * useful error message */
 			assert_string_equal(pgp_path->dev, pp_path->dev);
-			/* This test is just a backkup in case the
+			/* This test is just a backup in case the
 			 * something wenth wrong naming the paths */
 			assert_ptr_equal(pgp_path, pp_path);
 		}
diff --git a/tests/valid.c b/tests/valid.c
index e7393a1c..398b771e 100644
--- a/tests/valid.c
+++ b/tests/valid.c
@@ -293,7 +293,7 @@ static void test_sysfs_is_multipathed(void **state)
 
 	memset(&pp, 0, sizeof(pp));
 	conf.find_multipaths = FIND_MULTIPATHS_STRICT;
-	/* test for already existing multiapthed device */
+	/* test for already existing multipathed device */
 	will_return(__wrap_sysfs_is_multipathed, true);
 	will_return(__wrap_sysfs_is_multipathed, wwid);
 	assert_int_equal(is_path_valid(name, &conf, &pp, true),
@@ -452,7 +452,7 @@ static void test_greedy(void **state)
 	assert_string_equal(pp.dev, name);
 	assert_ptr_equal(pp.udev, &test_udev);
 	assert_string_equal(pp.wwid, wwid);
-	/* test greedy success without checking multiapthd */
+	/* test greedy success without checking multipathd */
 	memset(&pp, 0, sizeof(pp));
 	setup_passing(name, wwid, CHECK_MPATHD_SKIP, STAGE_IS_FAILED);
 	assert_int_equal(is_path_valid(name, &conf, &pp, false),
diff --git a/third-party/valgrind/valgrind.h b/third-party/valgrind/valgrind.h
index 577c8f05..1633b318 100644
--- a/third-party/valgrind/valgrind.h
+++ b/third-party/valgrind/valgrind.h
@@ -1075,7 +1075,7 @@ typedef
 
 /* Use these to write the name of your wrapper.  NOTE: duplicates
    VG_WRAP_FUNCTION_Z{U,Z} in pub_tool_redir.h.  NOTE also: inserts
-   the default behaviour equivalance class tag "0000" into the name.
+   the default behaviour equivalence class tag "0000" into the name.
    See pub_tool_redir.h for details -- normally you don't need to
    think about this, though. */
 
@@ -1620,11 +1620,11 @@ typedef
    and say that %r15 is trashed instead.  gcc seems happy to go with
    that.
 
-   Oh .. and this all needs to be conditionalised so that it is
+   Oh .. and this all needs to be conditionalized so that it is
    unchanged from before this commit, when compiled with older gccs
    that don't support __builtin_dwarf_cfa.  Furthermore, since
    this header file is freestanding, it has to be independent of
-   config.h, and so the following conditionalisation cannot depend on
+   config.h, and so the following conditionalization cannot depend on
    configure time checks.
 
    Although it's not clear from
@@ -1673,7 +1673,7 @@ typedef
 /* NB 9 Sept 07.  There is a nasty kludge here in all these CALL_FN_
    macros.  In order not to trash the stack redzone, we need to drop
    %rsp by 128 before the hidden call, and restore afterwards.  The
-   nastyness is that it is only by luck that the stack still appears
+   nastiness is that it is only by luck that the stack still appears
    to be unwindable during the hidden call - since then the behaviour
    of any routine using this macro does not match what the CFI data
    says.  Sigh.
